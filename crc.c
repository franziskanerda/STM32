/**********   #INCLUDES            **********/
#include "system.h"
#include "task.h"

/**********   #DEFINES             **********/
/**********   ENUMS                **********/
/**********   STRUCTS              **********/

/**********   CONSTS               **********/
// Lookup - Tabelle zum CRC berechnen
const u16 crc16_lookup[256] = 
{
   0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011, 0x8033, 0x0036,
   0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022, 0x8063, 0x0066, 0x006c, 0x8069,
   0x0078, 0x807d, 0x8077, 0x0072, 0x0050, 0x8055, 0x805f, 0x005a, 0x804b, 0x004e,
   0x0044, 0x8041, 0x80c3, 0x00c6, 0x00cc, 0x80c9, 0x00d8, 0x80dd, 0x80d7, 0x00d2,
   0x00f0, 0x80f5, 0x80ff, 0x00fa, 0x80eb, 0x00ee, 0x00e4, 0x80e1, 0x00a0, 0x80a5,
   0x80af, 0x00aa, 0x80bb, 0x00be, 0x00b4, 0x80b1, 0x8093, 0x0096, 0x009c, 0x8099,
   0x0088, 0x808d, 0x8087, 0x0082, 0x8183, 0x0186, 0x018c, 0x8189, 0x0198, 0x819d,
   0x8197, 0x0192, 0x01b0, 0x81b5, 0x81bf, 0x01ba, 0x81ab, 0x01ae, 0x01a4, 0x81a1,
   0x01e0, 0x81e5, 0x81ef, 0x01ea, 0x81fb, 0x01fe, 0x01f4, 0x81f1, 0x81d3, 0x01d6,
   0x01dc, 0x81d9, 0x01c8, 0x81cd, 0x81c7, 0x01c2, 0x0140, 0x8145, 0x814f, 0x014a,
   0x815b, 0x015e, 0x0154, 0x8151, 0x8173, 0x0176, 0x017c, 0x8179, 0x0168, 0x816d,
   0x8167, 0x0162, 0x8123, 0x0126, 0x012c, 0x8129, 0x0138, 0x813d, 0x8137, 0x0132,
   0x0110, 0x8115, 0x811f, 0x011a, 0x810b, 0x010e, 0x0104, 0x8101, 0x8303, 0x0306,
   0x030c, 0x8309, 0x0318, 0x831d, 0x8317, 0x0312, 0x0330, 0x8335, 0x833f, 0x033a,
   0x832b, 0x032e, 0x0324, 0x8321, 0x0360, 0x8365, 0x836f, 0x036a, 0x837b, 0x037e,
   0x0374, 0x8371, 0x8353, 0x0356, 0x035c, 0x8359, 0x0348, 0x834d, 0x8347, 0x0342,
   0x03c0, 0x83c5, 0x83cf, 0x03ca, 0x83db, 0x03de, 0x03d4, 0x83d1, 0x83f3, 0x03f6,
   0x03fc, 0x83f9, 0x03e8, 0x83ed, 0x83e7, 0x03e2, 0x83a3, 0x03a6, 0x03ac, 0x83a9,
   0x03b8, 0x83bd, 0x83b7, 0x03b2, 0x0390, 0x8395, 0x839f, 0x039a, 0x838b, 0x038e,
   0x0384, 0x8381, 0x0280, 0x8285, 0x828f, 0x028a, 0x829b, 0x029e, 0x0294, 0x8291,
   0x82b3, 0x02b6, 0x02bc, 0x82b9, 0x02a8, 0x82ad, 0x82a7, 0x02a2, 0x82e3, 0x02e6,
   0x02ec, 0x82e9, 0x02f8, 0x82fd, 0x82f7, 0x02f2, 0x02d0, 0x82d5, 0x82df, 0x02da,
   0x82cb, 0x02ce, 0x02c4, 0x82c1, 0x8243, 0x0246, 0x024c, 0x8249, 0x0258, 0x825d,
   0x8257, 0x0252, 0x0270, 0x8275, 0x827f, 0x027a, 0x826b, 0x026e, 0x0264, 0x8261,
   0x0220, 0x8225, 0x822f, 0x022a, 0x823b, 0x023e, 0x0234, 0x8231, 0x8213, 0x0216,
   0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
};

const u8 crc8_lookup[256] = 
{
   0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83,
   0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41,
   0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E,
   0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC,
   0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0,
   0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62,
   0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D,
   0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF,
   0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5,
   0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07,
   0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58,
   0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A,
   0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6,
   0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24,
   0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B,
   0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9,
   0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F,
   0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD,
   0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92,
   0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50,
   0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C,
   0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE,
   0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1,
   0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73,
   0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49,
   0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B,
   0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4,
   0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16,
   0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A,
   0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8,
   0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7,
   0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35
};



/**********   Public Variables     **********/
/**********   Public Functions     **********/
/**********   Private Variables    **********/
/**********   Private Functions    **********/
/**********   Code                 **********/

/******************************************************************************************************
                                                CalcCrc16
-------------------------------------------------------------------------------------------------------
Berechnet die CRC über einen gegebenen Speicherbereich ausgehend von einer gegebenen CRC.
Somit wird eine inkrementelle CRC-Berechnung ermöglicht, ansonst Crc auf 0 setzen.

Parameter:
   Crc:      Bisher errechnete CRC. Beim ersten Aufruf für einen Datenbereich auf 0 setzen.
   Start:    Zeiger auf Daten
   Len:      Anzahl Bytes über die die Crc gerechnet werden soll

Return: CRC
******************************************************************************************************/
inline u16 CalcCrc16( register u16 Crc, register const void *Start, register u32 Len ) 
{
   u8 *MyStart = (u8 *)Start;

   for (  ; Len > 0 ; Len-- ) 
      Crc = (Crc << 8) ^ crc16_lookup[(Crc >> 8) ^ ( *(MyStart++) )];
   return Crc;
}

/******************************************************************************************************
                                                CalcCrc16RunTasks
-------------------------------------------------------------------------------------------------------
Wie CalcCrc16 aber die Statemachine läuft während der Berechnung

Parameter:
   Crc:      Bisher errechnete CRC. Beim ersten Aufruf für einen Datenbereich auf 0 setzen.
   Start:    Zeiger auf Daten
   Len:      Anzahl Bytes über die die Crc gerechnet werden soll

Return: CRC
******************************************************************************************************/
u16 CalcCrc16RunTasks( register u16 Crc, register const void *Start, register u32 Len ) 
{
   u16 tasknr;
   u8  *MyStart = (u8 *)Start;

   tasknr = SuspendTask();

   for (  ; Len > 0 ; Len-- ) 
   {
      Crc = (Crc << 8) ^ crc16_lookup[(Crc >> 8) ^ ( *(MyStart++) )];
      TaskList();
   }

   ResumeTask( tasknr );
   return Crc;
}

/******************************************************************************************************
                                               CalcCrc8
-------------------------------------------------------------------------------------------------------
Berechnet eine 1-Byte lange CRC über einen gegebenen Speicherbereich ausgehend von einer gegebenen CRC.
Somit wird eine inkrementelle CRC-Berechnung ermöglicht, ansonst Crc auf 0 setzen.

Parameter:
   Crc:      Bisher errechnete CRC. Beim ersten Aufruf für einen Datenbereich auf 0 setzen.
   Start:    Zeiger auf Daten
   Len:      Anzahl Bytes über die die Crc gerechnet werden soll

Return: CRC
******************************************************************************************************/
u8 CalcCrc8( register u8 crc, void *start, register u32 len ) 
{
   u8 *s = start;

   for (  ; len > 0 ; len-- ) 
      crc = crc8_lookup[crc ^ *(s++)];
   return crc;
}


/******************************************************************************************************
                                              CheckBootCrc
-------------------------------------------------------------------------------------------------------
Testet die CRC des Bootloaders

Return:   0 OK: CRC aus BootInfo und berechnete CRC des Flash stimmen überein
        < 0 crc Fehler!
*****************************************************************************************************/

s16 CheckBootCrc( void )
{
/*
   char *MinAdr = (char *)&_sboot_info;
   char *MaxAdr = (MinAdr + 1024* 256);
   u16  crc = 0;
   s16  CrcOK = -1;
   u32  len;

   if ( (_sboot_info.boot_start_str > MinAdr) &&
       (_sboot_info.boot_start_str < MaxAdr) &&
       (_sboot_info.boot_stop_str > MinAdr) &&
       (_sboot_info.boot_stop_str < MaxAdr) )
   {
	   len = _sboot_info.boot_stop_str - _sboot_info.boot_start_str;
	   crc = CalcCrc16( 0, _sboot_info.boot_start_str, len );
	   if ( crc == _sboot_info.crc ) CrcOK = 0;
   }

   return CrcOK;
*/
	return 0;
}
